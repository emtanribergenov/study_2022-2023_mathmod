---
## Front matter
title: "Отчёт по лабораторной работе №1"
subtitle: "Работа с git"
author: "Танрибергенов Эльдар"

## Generic options
lang: ru-RU
toc-title: "Содержание"

## Bibliography
bibliography: bib/cite.bib
csl: pandoc/csl/gost-r-7-0-5-2008-numeric.csl

## Pdf output format
toc: true # Table of contents
toc-depth: 2
lof: true # List of figures
lot: true # List of tables
fontsize: 12pt
linestretch: 1.5
papersize: a4
documentclass: scrreprt
## I18n polyglossia
polyglossia-lang:
  name: russian
  options:
	- spelling=modern
	- babelshorthands=true
polyglossia-otherlangs:
  name: english
## I18n babel
babel-lang: russian
babel-otherlangs: english
## Fonts
mainfont: PT Serif
romanfont: PT Serif
sansfont: PT Sans
monofont: PT Mono
mainfontoptions: Ligatures=TeX
romanfontoptions: Ligatures=TeX
sansfontoptions: Ligatures=TeX,Scale=MatchLowercase
monofontoptions: Scale=MatchLowercase,Scale=0.9
## Biblatex
biblatex: true
biblio-style: "gost-numeric"
biblatexoptions:
  - parentracker=true
  - backend=biber
  - hyperref=auto
  - language=auto
  - autolang=other*
  - citestyle=gost-numeric
## Pandoc-crossref LaTeX customization
figureTitle: "Рис."
tableTitle: "Таблица"
listingTitle: "Листинг"
lofTitle: "Список иллюстраций"
lotTitle: "Список таблиц"
lolTitle: "Листинги"
## Misc options
indent: true
header-includes:
  - \usepackage{indentfirst}
  - \usepackage{float} # keep figures where there are in the text
  - \floatplacement{figure}{H} # keep figures where there are in the text
---

# Цель работы

Создать git репозиторий, выполнить различные команды.

# Задание

Выполнить задания по работе с git.

# Выполнение лабораторной работы

## Подготовка
### Установка имени и электронной почты
Если вы никогда ранее не использовали git, для начала вам необходимо осуществить установку. Выполните следующие команды, чтобы git узнал ваше имя и
электронную почту. Если git уже установлен, можете переходить к разделу окончания строк.
git config --global user.name "Your Name"
git config --global user.email "your_email@whatever.com"

### Параметры установки окончаний строк
Настройка core.autocrlf с параметрами true и input делает все переводы
строк текстовых файлов в главном репозитории одинаковы.
core.autocrlf true - git автоматически конвертирует CRLF->LF при коммите и обратно LF->CRLF при выгрузке кода из репозитория на файловую систему
(используют в Windows). core.autocrlf input - конвертация CRLF в LF только
при коммитах (используют в Mac/Linux).
Если core.safecrlf установлен в true или warm, git проверяет, если преобразование является обратимым для текущей настройки core.autocrlf.
core.safecrlf true - отвержение необратимого преобразования lf<->crlf.
Полезно, когда специфические бинарники похожие на текстовые файлы.
core.safecrlf warn - печать только предупреждение, но принимает необратимый переход.
Для пользователей Windows:
git config --global core.autocrlf true
git config --global core.safecrlf true

### Установка отображения unicode
По умолчанию, git будет печатать не-ASCII символов в именах файлов в виде
восьмеричных последовательностей \nnn. Что бы избежать нечитаемых строк,
установите соответствующий флаг.
git config --global core.quotepath off

## Создание проекта
### Создание страницы «Hello, World»
Начните работу в пустом рабочем каталоге с создания пустого каталога с именем
hello, затем войдите в него и создайте там файл с именем hello.html.

### Создание репозитория
Чтобы создать git репозиторий из этого каталога, выполните команду git init.

### Добавление файла в репозиторий
Добавим файл в репозиторий.

### Проверка состояние репозитория
Используйте команду git status, чтобы проверить текущее состояние репозитория.

## Внесение изменений
### Измените страницу «Hello, World»
Добавим кое-какие HTML-теги к нашему приветствию.

## Индексация изменений
Теперь выполните команду git add, чтобы проиндексировать изменения. Проверьте
состояние.

### Коммит изменений
Сделайте коммит и проверьте состояние.
git commit
Откроется редактор.
В первой строке введите комментарий: «Added h1 tag». Сохраните файл и выйдите из редактора (для этого в редакторе по-умолчанию (Vim) вам нужно нажать
клавишу ESC, ввести :wq и нажать Enter).
Теперь еще раз проверим состояние.
git status
Рабочий каталог чистый, можно продолжить работу

### Добавьте стандартные теги страницы
Измените страницу «Hello, World», чтобы она содержала стандартные теги <html> и <body>.
Теперь добавьте это изменение в индекс git.
Теперь добавьте заголовки HTML (секцию <head>) к странице «Hello, World»
Проверьте текущий статус. Обратите внимание на то, что hello.html указан дважды в состоянии. Первое изменение (добавление стандартных тегов) проиндексировано и готово к
коммиту. Второе изменение (добавление заголовков HTML) является непроиндексированным. Если бы вы делали коммит сейчас, заголовки не были бы сохранены
в репозиторий.
Произведите коммит проиндексированного изменения (значение по умолчанию), а затем еще раз проверьте состояние.
Состояние команды говорит о том, что hello.html имеет незафиксированные
изменения, но уже не в буферной зоне.
Теперь добавьте второе изменение в индекс, а затем проверьте состояние с
помощью команды git status.
В качестве файла для добавления, мы использовали текущий каталог (.). Это
краткий и удобный путь для добавления всех изменений в файлы текущего каталога
и его подкаталоги. Но поскольку он добавляет все, не лишним будет проверить
состояние перед запуском add, просто чтобы убедиться, что вы не добавили какойто файл, который добавлять было не нужно.
Второе изменение было проиндексировано и готово к коммиту.
Сделайте коммит второго изменения

### История
Получим список произведенных изменений
Однострочный формат истории
Есть много вариантов отображения лога
Справочная страница

### Получение старых версий
Возвращаться назад в историю очень просто. Команда checkout скопирует любой
снимок из репозитория в рабочий каталог.
Получите хэши предыдущих версий.
Изучите данные лога и найдите хэш для первого коммита. Он должен быть в
последней строке данных. Используйте этот хэш-код (достаточно первых 7 знаков)
в команде ниже. Затем проверьте содержимое файла hello.html.
Вернитесь к последней версии в ветке master.

### Создание тегов версий
Давайте назовем текущую версию страницы hello первой (v1).
Создайте тег первой версии.
Теперь текущая версия страницы называется v1.
Теги для предыдущих версий Давайте создадим тег для версии, которая идет
перед текущей версией и назовем его v1-beta. В первую очередь нам надо переключиться на предыдущую версию. Вместо поиска до хэш, мы будем использовать
^, обозначающее «родитель v1». Вместо обозначения v1^ можно использовать
v1~1. Это обозначение можно определить как «первую версию предшествующую
v1».
Это версия c тегами <html> и <body>, но еще пока без <head>. Давайте сделаем
ее версией v1-beta.

### Переключение по имени тега
Теперь попробуйте попереключаться между двумя отмеченными версиями

### Просмотр тегов с помощью команды tag
Вы можете увидеть, какие теги доступны, используя команду git tag
Вы также можете посмотреть теги в логе.
Вы можете видеть теги (v1 и v1-beta) в логе вместе с именем ветки (master).
Кроме того HEAD показывает коммит, на который вы переключились (на данный
момент это v1-beta).

## Отмена локальных изменений (до индексации)
### Переключитесь на ветку master
Убедитесь, что вы находитесь на последнем коммите ветки master, прежде чем
продолжить работу.

### Измените hello.html
Иногда случается, что вы изменили файл в рабочем каталоге, и хотите отменить
последние коммиты. С этим справится команда git checkout.
Внесите изменение в файл hello.html в виде нежелательного комментария.

### Проверьте состояние
Сначала проверьте состояние рабочего каталога.
Мы видим, что файл hello.html был изменен, но еще не проиндексирован.

### Отмена изменений в рабочем каталоге
Используйте команду git checkout для переключения версии файла
hello.html в репозитории.
Команда git status показывает нам, что не было произведено никаких изменений, не зафиксированных в рабочем каталоге.

## Отмена проиндексированных изменений (перед коммитом)
### Измените файл и проиндексируйте изменения
Внесите изменение в файл hello.html в виде нежелательного комментария.
Проиндексируйте это изменение.

###  Проверьте состояние
Проверьте состояние нежелательного изменения.
Состояние показывает, что изменение было проиндексировано и готово к коммиту.

### Выполните сброс буферной зоны
К счастью, вывод состояния показывает нам именно то, что мы должны сделать
для отмены индексации изменения.
Команда git reset сбрасывает буферную зону к HEAD. Это очищает буферную
зону от изменений, которые мы только что проиндексировали.
Команда git reset (по умолчанию) не изменяет рабочий каталог. Поэтому
рабочий каталог все еще содержит нежелательный комментарий. Мы можем использовать команду git checkout, чтобы удалить нежелательные изменения в
рабочем каталоге.

### Переключитесь на версию коммита
Наш рабочий каталог опять чист.

## Отмена коммитов
### Отмена коммитов
Иногда вы понимаете, что новые коммиты являются неверными, и хотите их
отменить. Есть несколько способов решения этого вопроса, здесь мы будем использовать самый безопасный.
Мы отменим коммит путем создания нового коммита, отменяющего нежелательные изменения.

### Измените файл и сделайте коммит
Измените файл hello.html 
Выполните

### Сделайте коммит с новыми изменениями, отменяющими предыдущие
Чтобы отменить коммит, нам необходимо сделать коммит, который удаляет изменения, сохраненные нежелательным коммитом.
Перейдите в редактор, где вы можете отредактировать коммит-сообщение по
умолчанию или оставить все как есть. Сохраните и закройте файл.
Так как мы отменили самый последний произведенный коммит, мы смогли
использовать HEAD в качестве аргумента для отмены. Мы можем отменить любой
произвольной коммит в истории, указав его хэш-значение.

### Проверьте лог
Проверка лога показывает нежелательные и отмененные коммиты в наш репозиторий.
Эта техника будет работать с любым коммитом.

## Удаление коммиттов из ветки
git revert является мощной командой, которая позволяет отменить любые коммиты в репозиторий. Однако, и оригинальный и «отмененный» коммиты видны в
истории ветки (при использовании команды git log).
Часто мы делаем коммит, и сразу понимаем, что это была ошибка. Было бы
неплохо иметь команду «возврата», которая позволила бы нам сделать вид, что
неправильного коммита никогда и не было. Команда «возврата» даже предотвратила бы появление нежелательного коммита в истории git log.

###  Команда git reset
При получении ссылки на коммит (т.е. хэш, ветка или имя тега), команда git
reset:
• перепишет текущую ветку, чтобы она указывала на нужный коммит;
• опционально сбросит буферную зону для соответствия с указанным коммитом;
• опционально сбросит рабочий каталог для соответствия с указанным коммитом.

###  Проверьте нашу историю
Давайте сделаем быструю проверку нашей истории коммитов.
Мы видим, что два последних коммита в этой ветке — «Oops» и «Revert Oops».
Давайте удалим их с помощью сброса.

### Для начала отметьте эту ветку
Но прежде чем удалить коммиты, давайте отметим последний коммит тегом, чтобы
потом можно было его найти.

###  Сброс коммитов к предшествующим коммиту Oops
Глядя на историю лога, мы видим, что коммит с тегом «v1» является коммитом,
предшествующим ошибочному коммиту. Давайте сбросим ветку до этой точки.
Поскольку ветка имеет тег, мы можем использовать имя тега в команде сброса
(если она не имеет тега, мы можем использовать хэш-значение).
Наша ветка master теперь указывает на коммит v1, а коммитов Oops и Revert
Oops в ветке уже нет. Параметр --hard указывает, что рабочий каталог должен
быть обновлен в соответствии с новым head ветки.

### Ничего никогда не теряется
Что же случается с ошибочными коммитами? Оказывается, что коммиты все еще
находятся в репозитории. На самом деле, мы все еще можем на них ссылаться.
Помните, в начале этого урока мы создали для отмененного коммита тег «oops».
Давайте посмотрим на все коммиты.
Мы видим, что ошибочные коммиты не исчезли. Они все еще находятся в репозитории. Просто они отсутствуют в ветке master. Если бы мы не отметили их
тегами, они по-прежнему находились бы в репозитории, но не было бы никакой
возможности ссылаться на них, кроме как при помощи их хэш имен. Коммиты, на
которые нет ссылок, остаются в репозитории до тех пор, пока не будет запущен
сборщик мусора.

### Опасность сброса
Сброс в локальных ветках, как правило, безопасен. Последствия любой «аварии»
как правило, можно восстановить простым сбросом с помощью нужного коммита.
Однако, если ветка «расшарена» на удаленных репозиториях, сброс может сбить с
толку других пользователей ветки.

## Удаление тега oops
### Удаление тега oops
Тег oops свою функцию выполнил. Давайте удалим его и коммиты, на которые он
ссылался, сборщиком мусора.
Тег «oops» больше не будет отображаться в репозитории.

## Внесение изменений в коммиты
### Измените страницу, а затем сделайте коммит
Добавьте в страницу комментарий автора (вставьте свою фамилию)
Выполните

###  Необходим email
После совершения коммита вы понимаете, что любой хороший комментарий должен включать электронную почту автора. Обновите страницу hello, включив в
нее email.

### Измените предыдущий коммит
Мы действительно не хотим создавать отдельный коммит только ради электронной
почты. Давайте изменим предыдущий коммит, включив в него адрес электронной
почты.
Выполните:

### Просмотр истории
Мы можем увидеть, что оригинальный коммит «автор» заменен коммитом «автор/email». Этого же эффекта можно достичь путем сброса последнего коммита в
ветке, и повторного коммита новых изменений.

##  Перемещение файлов
### Переместите файл hello.html в каталог lib
Сейчас мы собираемся создать структуру нашего репозитория. Давайте перенесем
страницу в каталог lib.
Перемещая файлы с помощью git mv, мы информируем git о 2 вещах:
• Что файл hello.html был удален.
• Что файл lib/hello.html был создан.
• Оба эти факта сразу же проиндексированы и готовы к коммиту. Команда git
status сообщает, что файл был перемещен.

## Второй способ перемещения файлов
Положительной чертой git является то, что вы можете забыть о версионном контроле до того момента, когда вы готовы приступить к коммиту кода. Что бы случилось, если бы мы использовали командную строку операционной системы для
перемещения файлов вместо команды git?
Следующий набор команд идентичен нашим последним действиям. Работы
здесь побольше, но результат тот же.
Мы могли бы выполнить:

### Коммит в новый каталог
Давайте сделаем коммит этого перемещения:

## Подробнее о структуре
###  Добавление index.html
Добавим файл index.html в наш репозиторий
Добавьте файл и сделайте коммит.
Теперь при открытии index.html, вы должны увидеть кусок страницы hello в
маленьком окошке.

## Git внутри: Каталог .git
###  Каталог .git
Это каталог, в котором хранится вся информация git.

###  База данных объектов
Вы должны увидеть набор каталогов, имена которых состоят из 2 символов. Имена каталогов являются первыми двумя буквами хэша sha1 объекта, хранящегося в
git.

### Углубляемся в базу данных объектов
Смотрим в один из каталогов с именем из 2 букв. Вы увидите файлы с именами
из 38 символов. Это файлы, содержащие объекты, хранящиеся в git. Они сжаты и
закодированы, поэтому просмотр их содержимого нам мало чем поможет.

### Config File
Это файл конфигурации, создающийся для каждого конкретного проекта. Записи
в этом файле будут перезаписывать записи в файле .gitconfig вашего главного
каталога, по крайней мере в рамках этого проекта

###  Ветки и теги
Выполните:
Вы должны узнавать файлы в подкаталоге тегов. Каждый файл соответствует
тегу, ранее созданному с помощью команды git tag. Его содержание — это всего
лишь хэш коммита, привязанный к тегу.
Каталог heads практически аналогичен, но используется для веток, а не тегов.
На данный момент у нас есть только одна ветка, так что все, что вы увидите в этом
каталоге – это ветка master.

### Файл HEAD
Файл HEAD содержит ссылку на текущую ветку, в данный момент это должна
быть ветка master.

## Работа непосредственно с объектами git
### Поиск последнего коммита
Эта команда должна показать последний коммит в репозиторий. SHA1 хэш в
вашей системе, вероятно, отличается от моего, но вы увидите что-то наподобие
этого.

###  Вывод последнего коммита с помощью SHA1 хэша

### Поиск дерева
Мы можем вывести дерево каталогов, ссылка на который идет в коммите. Это должно быть описание файлов (верхнего уровня) в нашем проекте (для конкретного
коммита). Используйте SHA1 хэш из строки «дерева», из списка выше.

### Вывод каталога lib

### Вывод файла hello.html

### Исследуйте самостоятельно
Исследуйте git репозиторий вручную самостоятельно. Смотрите, удастся ли вам
найти оригинальный файл hello.html с самого первого коммита вручную по ссылкам SHA1 хэша в последнем коммите.

## Создание ветки
### Создайте ветку
Давайте назовем нашу новую ветку «style».
git checkout -b <имя_ветки> является шорткатом для git branch
<имя_ветки> за которым идет git checkout <имя_ветки>.
Обратите внимание, что команда git status сообщает о том, что вы находитесь в ветке «style».

###  Добавьте файл стилей style.css

###  Измените основную страницу
Обновите файл hello.html, чтобы использовать стили style.css.

### Измените index.html
Обновите файл index.html, чтобы он тоже использовал style.css

## Навигация по веткам
Теперь в вашем проекте есть две ветки:
Выполните: git log --all

###  Переключение на ветку master
Используйте команду git checkout для переключения между ветками
Сейчас мы находимся на ветке master. Это заметно по тому, что файл
hello.html не использует стили style.css.


### Вернемся к ветке style
Содержимое lib/hello.html подтверждает, что мы вернулись на ветку style.

##  Изменения в ветке master
Пока вы меняли ветку style, кто-то решил обновить ветку master. Они добавили
файл README.md.

### Создайте файл README в ветке master
Выполните:
git checkout master
Создайте файл README.md

## Сделайте коммит изменений README.md в ветку master.

### Просмотр отличающихся веток
### Просмотрите текущие ветки
Теперь у нас в репозитории есть две отличающиеся ветки. Используйте следующую
лог-команду для просмотра веток и их отличий. 
Добавление опции --graph в git log вызывает построение дерева коммитов
с помощью простых ASCII символов. Мы видим обе ветки (style и master), и то,
что ветка master является текущей HEAD. Общим предшественником обеих веток
является коммит «Added index.html».
Опция --all гарантированно означает, что мы видим все ветки. По умолчанию
показывается только текущая ветка.

##  Слияние
### Слияние веток
Слияние переносит изменения из двух веток в одну. Давайте вернемся к ветке
style и сольем master с style.
Путем периодического слияния ветки master с веткой style вы можете переносить из master любые изменения и поддерживать совместимость изменений
style с изменениями в основной ветке.
Но что если изменения в ветке master конфликтуют с изменениями в style?

## Создание конфликта
###  Вернитесь в master и создайте конфликт
Вернитесь в ветку master и внесите следующие изменения:

### Просмотр веток
После коммита «Added README» ветка master была объединена с веткой style,
но в настоящее время в master есть дополнительный коммит, который не был слит
с style.
Последнее изменение в master конфликтует с некоторыми изменениями в
style. На следующем шаге мы решим этот конфликт.

## Разрешение конфликтов
### Слияние master с веткой style
Теперь вернемся к ветке style и попытаемся объединить ее с новой веткой
master.

### Решение конфликта
Вам необходимо вручную разрешить конфликт. Внесите изменения в lib/hello.html
для достижения следующего результата.

### Сделайте коммит решения конфликта

###  Перебазирование как альтернатива слиянию
Рассмотрим различия между слиянием и перебазированием. Для того, чтобы это
сделать, нам нужно вернуться в репозиторий в момент до первого слияния, а затем
повторить те же действия, но с использованием перебазирования вместо слияния.
Мы будем использовать команду reset для возврата веток к предыдущему
состоянию.

## Сброс ветки style
### Сброс ветки style
Вернемся на ветке style к точке перед тем, как мы слили ее с веткой master. Мы
можем сбросить ветку к любому коммиту. По сути, это изменение указателя ветки
на любую точку дерева коммитов.
В этом случае мы хотим вернуться в ветке style в точку перед слиянием с master.
Нам необходимо найти последний коммит перед слиянием.
Мы видим, что коммит «Updated index.html» был последним на ветке style
перед слиянием. Давайте сбросим ветку style к этому коммиту.

### Проверьте ветку.
Поищите лог ветки style. У нас в истории больше нет коммитов слияний.

## Сброс ветки master
### Сброс ветки master
Добавив интерактивный режим в ветку master, мы внесли изменения, конфликтующие с изменениями в ветке style. Давайте вернемся в ветке master в точку
перед внесением конфликтующих изменений. Это позволяет нам продемонстрировать работу команды git rebase, не беспокоясь о конфликтах.
Коммит «Added README» идет непосредственно перед коммитом конфликтующего интерактивного режима. Мы сбросим ветку master к коммиту «Added
README».
Просмотрите лог. Он должен выглядеть, как будто репозиторий был перемотан
назад во времени к точке до какого-либо слияния.

##  Перебазирование
Используем команду rebase вместо команды merge. Мы вернулись в точку до первого слияния и хотим перенести изменения из ветки master в нашу ветку style.
На этот раз для переноса изменений из ветки master мы будем использовать
команду git rebase вместо слияния.

### Слияние VS перебазирование
Конечный результат перебазирования очень похож на результат слияния. Ветка
style в настоящее время содержит все свои изменения, а также все изменения
ветки master. Однако, дерево коммитов значительно отличается. Дерево коммитов ветки style было переписано таким образом, что ветка master является
частью истории коммитов. Это делает цепь коммитов линейной и гораздо более
читабельной.

## Слияние в ветку master
### Слияние style в master
Поскольку последний коммит ветки master прямо предшествует последнему
коммиту ветки style, git может выполнить ускоренное слияние-перемотку. При
быстрой перемотке вперед git просто передвигает указатель вперед, таким образом указывая на тот же коммит, что и ветка style.
При быстрой перемотке конфликтов быть не может.

### Просмотрите логи
Теперь ветки style и master идентичны.

## Клонирование репозиториев
###Перейдите в рабочий каталог
Перейдите в рабочий каталог и сделайте клон вашего репозитория hello
Сейчас мы находимся в рабочем каталоге.
В этот момент вы должны находиться в «рабочем» каталоге. Здесь должен быть
единственный репозиторий под названием «hello».

### Создайте клон репозитория hello
Создадим клон репозитория.
В вашем рабочем каталоге теперь должно быть два репозитория: оригинальный
репозиторий «hello» и клонированный репозиторий «cloned_hello»

##  Просмотр клонированного репозитория
### Давайте взглянем на клонированный репозиторий
Вы увидите список всех файлов на верхнем уровне оригинального репозитория
README.md, index.html и lib

### Просмотрите историю репозитория
Вы увидите список всех коммитов в новый репозиторий, и он должен (более или
менее) совпадать с историей коммитов в оригинальном репозитории. Единственная разница должна быть в названиях веток.

### Удалённые ветки
ы увидите ветку master (HEAD) в списке истории. Вы также увидите ветки со
странными именами (origin/master, origin/style и origin/HEAD).

## Что такое origin?
Мы видим, что клонированный репозиторий знает об имени по умолчанию
удаленного репозитория. Давайте посмотрим, можем ли мы получить более подробную информацию об имени по умолчанию:
Удаленные репозитории обычно размещаются на отдельной машине, возможно, централизованном сервере. Однако, как мы видим здесь, они могут с тем же
успехом указывать на репозиторий на той же машине. Нет ничего особенного
в имени «origin», однако существует традиция использовать «origin» в качестве
имени первичного централизованного репозитория (если таковой имеется).

## Удаленные ветки
Давайте посмотрим на ветки, доступные в нашем клонированном репозитории.
Git выводит все коммиты в оригинальный репозиторий, но ветки в удаленном
репозитории не рассматриваются как локальные. Если мы хотим собственную ветку
style, мы должны сами ее создать. Через минуту вы увидите, как это делается.

## Изменение оригинального репозитория
Внесите некоторые изменения в оригинальный репозиторий, чтобы затем попытаться извлечь и слить изменения из удаленной ветки в текущую

### Внесите изменения в оригинальный репозиторий hello
Примечание: Сейчас мы находимся в репозитории hello
Внесите следующие изменения в файл README.md:
Файл README.md
Теперь добавьте это изменение и сделайте коммит

### Извлечение изменений
Научиться извлекать изменения из удаленного репозитория.
Сейчас мы находимся в репозитории cloned_hello.
На данный момент в репозитории есть все коммиты из оригинального репозитория, но они не интегрированы в локальные ветки клонированного репозитория.
В истории выше найдите коммит «Changed README in original repo». Обратите
внимание, что коммит включает в себя коммиты «origin/master» и «origin/HEAD».
Теперь давайте посмотрим на коммит «Updated index.html». Вы увидите, что
локальная ветка master указывает на этот коммит, а не на новый коммит, который
мы только что извлекли.
Выводом является то, что команда git fetch будет извлекать новые коммиты из удаленного репозитория, но не будет сливать их с вашими наработками в
локальных ветках.

###  Проверьте README.md
Мы можем продемонстрировать, что клонированный файл README.md не изменился.

## Слияние извлеченных изменений
### Слейте извлеченные изменения в локальную ветку master
### Еще раз проверьте файл README.md
Хотя команда git fetch не сливает изменения, мы можем вручную слить изменения из удаленного репозитория.
Теперь давайте рассмотрим объединение fetch и merge в одну команду. Выполнение:

## Добавление ветки наблюдения
Ветки, которые начинаются с remotes/origin являются ветками оригинального
репозитория. Обратите внимание, что у вас больше нет ветки под названием style,
но система контроля версий знает, что в оригинальном репозитории ветка style
была.

### Добавьте локальную ветку, которая отслеживает удаленную ветку
Теперь мы можем видеть ветку style в списке веток и логе.

##Чистые репозитории
Чистые репозитории (без рабочих каталогов) обычно используются для расшаривания. Обычный git-репозиторий подразумевает, что вы будете использовать
его как рабочую директорию, поэтому вместе с файлами проекта в актуальной
версии, git хранит все служебные, «чисто-репозиториевские» файлы в поддиректории .git. В удаленных репозиториях нет смысла хранить рабочие файлы на диске
(как это делается в рабочих копиях), а все что им действительно нужно — это дельты изменений и другие бинарные данные репозитория. Вот это и есть «чистый
репозиторий».

## Создайте чистый репозиторий
Сейчас мы находимся в рабочем каталоге
Как правило, репозитории, оканчивающиеся на .git являются чистыми репозиториями. Мы видим, что в репозитории hello.git нет рабочего каталога. По сути,
это есть не что иное, как каталог .git нечистого репозитория.

## Добавление удаленного репозитория
Давайте добавим репозиторий hello.git к нашему оригинальному репозиторию.

## Отправка изменений
Так как чистые репозитории, как правило, расшариваются на каком-нибудь сетевом сервере, нам необходимо отправить наши изменения в другие репозитории.
Начнем с создания изменения для отправки. Отредактируйте файл README.md и
сделайте коммит.
Теперь отправьте изменения в общий репозиторий.
Общим называется репозиторий, получающий отправленные нами изменения.

## Извлечение общих изменений
Научиться извлекать изменения из общего репозитория. Быстро переключитесь в
клонированный репозиторий и извлеките изменения, только что отправленные в
общий репозиторий.
Сейчас мы находимся в репозитории cloned_hello.



## Результаты

![траектории для случая 1](images/L2_jl_01.png){ #fig:001 width=70% height=70% }

Точка пересечения катера и лодки, исходя из графика, имеет приблизительные координаты

$$
 \begin{cases}
   \theta=315
   \\
	r=12
 \end{cases}
\
$$

![траектории для случая 2](images/L2_jl_02.png){ #fig:002 width=70% height=70% }

Точка пересечения катера и лодки, исходя из графика, имеет приблизительные координаты

$$
 \begin{cases}
   \theta=315
   \\
	r=9
 \end{cases}
\
$$


# Выводы

Я рассмотрел задачу о погоне, провели анализ и вывод дифференциальных уравнений, смоделировали ситуацию, нашел точки пересечения катера и лодки.


